.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.IX Title "CG_LANGUAGE Cg"
.TH CG_LANGUAGE Cg "Cg Toolkit 3.0" "perl v5.10.0" "Cg Language Specification"
.if n .ad l
.nh
.SH "Cg Language Specification"
.IX Header "Cg Language Specification"
Copyright (c) 2001\-2011 \s-1NVIDIA\s0 Corp.
.PP
This is version 2.0 of the Cg Language specification.  This language
specification describes version 2.0 of the Cg language
.SH "Language Overview"
.IX Header "Language Overview"
The Cg language is primarily modeled on \s-1ANSI\s0 C, but adopts some ideas from
modern languages such as \*(C+ and Java, and from earlier shading languages
such as RenderMan and the Stanford shading language. The language also
introduces a few new ideas.  In particular, it includes features designed
to represent data flow in stream-processing architectures such as GPUs.
Profiles, which are specified at compile time, may subset certain
features of the language, including the ability to implement loops and
the precision at which certain computations are performed.
.PP
Like C, Cg is designed primarily as a low-level programming language.
Features are provided that map as directly as possible to hardware
capabilities.  Higher level abstractions are designed primarily to not
get in the way of writing code that maps directly to the hardware in
the most efficient way possible.  The changes in the language from C
primarily reflect differences in the way \s-1GPU\s0 hardware works compared
to conventional CPUs.  GPUs are designed to run large numbers of small
threads of processing in parallel, each running a copy of the same program
on a different data set.
.SH "Differences from ANSI C"
.IX Header "Differences from ANSI C"
Cg was developed based on the ANSI-C language with the following major
additions, deletions, and changes. (This is a summary-more detail is
provided later in this document):
.Sh "Silent Incompatibilities"
.IX Subsection "Silent Incompatibilities"
Most of the changes from \s-1ANSI\s0 C are either omissions or additions,
but there are a few potentially silent incompatibilities.  These are
changes within Cg that could cause a program that compiles
without errors to behave in a manner different from C:
.IP "\(bu" 4
The type promotion rules for constants are different when the constant
is not explicitly typed using a type cast or type suffix. In general,
a binary operation between a constant that is not explicitly typed and
a variable is performed at the variable's precision, rather than at the
constant's default precision.
.IP "\(bu" 4
Declarations of \f(CW\*(C`struct\*(C'\fR perform an automatic \f(CW\*(C`typedef\*(C'\fR (as in \*(C+) and
thus could override a previously declared type.
.IP "\(bu" 4
Arrays are first-class types that are distinct from pointers.  As a
result, array assignments semantically perform a copy operation for the
entire array.
.Sh "Similar Operations That Must be Expressed Differently"
.IX Subsection "Similar Operations That Must be Expressed Differently"
There are several changes that force the same operation to be
expressed differently in Cg than in C:
.IP "\(bu" 4
A Boolean type, \f(CW\*(C`bool\*(C'\fR, is introduced, with corresponding implications
for operators and control constructs.
.IP "\(bu" 4
Arrays are first-class types because Cg does not support pointers.
.IP "\(bu" 4
Functions pass values by value/result, and thus use an \f(CW\*(C`out\*(C'\fR or \f(CW\*(C`inout\*(C'\fR
modifier in the formal parameter list to return a parameter.  By default,
formal parameters are \f(CW\*(C`in\*(C'\fR, but it is acceptable to specify this explicitly.
Parameters can also be specified as \f(CW\*(C`in out\*(C'\fR, which is semantically the
same as \f(CW\*(C`inout\*(C'\fR.
.Sh "C features not present in Cg"
.IX Subsection "C features not present in Cg"
.IP "\(bu" 4
Language profiles (described in the Profiles section) may
subset language capabilities in a variety of ways.  In particular,
language profiles may restrict the use of for and while loops.
For example, some profiles may only support loops that can be fully
unrolled at compile time.
.IP "\(bu" 4
Reserved keywords \f(CW\*(C`goto\*(C'\fR, \f(CW\*(C`switch\*(C'\fR, \f(CW\*(C`case\*(C'\fR, and \f(CW\*(C`default\*(C'\fR are not
supported, nor are labels.
.IP "\(bu" 4
Pointers and pointer-related capabilities, such as the \f(CW\*(C`&\*(C'\fR and
\&\f(CW\*(C`\->\*(C'\fR operators, are not supported.
.IP "\(bu" 4
Arrays are supported, but with some limitations on size and
dimensionality.  Restrictions on the use of computed subscripts are also
permitted.  Arrays may be designated as \f(CW\*(C`packed\*(C'\fR.  The operations allowed on
packed arrays may be different from those allowed on unpacked arrays.
Predefined \f(CW\*(C`packed\*(C'\fR types are provided for vectors and matrices. It
is strongly recommended that these predefined types be used.
.IP "\(bu" 4
There is no \f(CW\*(C`enum\*(C'\fR or \f(CW\*(C`union\*(C'\fR.
.IP "\(bu" 4
There are no bit-field declarations in structures.
.IP "\(bu" 4
All integral types are implicitly signed, there is no \fIsigned\fR keyword.
.Sh "Cg features not present in C"
.IX Subsection "Cg features not present in C"
.IP "\(bu" 4
A \fIbinding semantic\fR may be associated with a structure tag, a
variable, or a structure element to denote that object's mapping
to a specific hardware or \s-1API\s0 resource.  Binding semantics are described
in the \fIBinding Semantics\fR section.
.IP "\(bu" 4
There is a built-in swizzle operator: \f(CW\*(C`.xyzw\*(C'\fR or \f(CW\*(C`.rgba\*(C'\fR for vectors.
This operator allows the components of a vector to be rearranged and also
replicated.  It also allows the creation of a vector from a scalar.
.IP "\(bu" 4
For an lvalue, the swizzle operator allows components of a vector or
matrix to be selectively written.
.IP "\(bu" 4
There is a similar built-in swizzle operator for matrices:
\&\f(CW\*(C`._m<row><col>[_m<row><col>][...]\*(C'\fR.  This operator allows access to
individual matrix components and allows the creation of a vector from
elements of a matrix.  For compatibility with DirectX 8 notation, there
is a second form of matrix swizzle, which is described later.
.IP "\(bu" 4
Numeric data types are different.
Cg's primary numeric data types are \f(CW\*(C`float\*(C'\fR, \f(CW\*(C`half\*(C'\fR, and \f(CW\*(C`fixed\*(C'\fR.
Fragment profiles are required to support all three data types, but
may choose to implement \f(CW\*(C`half\*(C'\fR and/or \f(CW\*(C`fixed\*(C'\fR at \f(CW\*(C`float\*(C'\fR precision.
Vertex profiles are required to support \f(CW\*(C`half\*(C'\fR and \f(CW\*(C`float\*(C'\fR, but
may choose to implement \f(CW\*(C`half\*(C'\fR at \f(CW\*(C`float\*(C'\fR precision.
Vertex profiles may omit support for \f(CW\*(C`fixed\*(C'\fR operations, but must
still support definition of \f(CW\*(C`fixed\*(C'\fR variables.
Cg allows profiles to omit run-time support for \f(CW\*(C`int\*(C'\fR and other integer types.
Cg allows profiles to treat \f(CW\*(C`double\*(C'\fR as \f(CW\*(C`float\*(C'\fR.
.IP "\(bu" 4
Many operators support per-element vector operations.
.IP "\(bu" 4
The \f(CW\*(C`?:\*(C'\fR, \f(CW\*(C`||\*(C'\fR, \f(CW\*(C`&&\*(C'\fR, \f(CW\*(C`!\*(C'\fR, and comparison operators can be used with
\&\f(CW\*(C`bool\*(C'\fR vectors to perform multiple conditional operations
simultaneously.
The side effects of all operands to vector \f(CW\*(C`?:\*(C'\fR, \f(CW\*(C`||\*(C'\fR, and \f(CW\*(C`&&\*(C'\fR operators are
always executed.
.IP "\(bu" 4
Non-static global variables, and parameters to top-level functions
(such as \fImain()\fR) may be designated as \f(CW\*(C`uniform\*(C'\fR.  A \f(CW\*(C`uniform\*(C'\fR
variable may be read and written within a program, just like any
other variable.  However, the uniform modifier indicates that the
initial value of the variable/parameter is expected to be constant
across a large number of invocations of the program.
.IP "\(bu" 4
A new set of \f(CW\*(C`sampler*\*(C'\fR types represents handles to texture sampler units.
.IP "\(bu" 4
Functions may have default values for their parameters, as in \*(C+.
These defaults are expressed using assignment syntax.
.IP "\(bu" 4
Function and operator overloading is supported.
.IP "\(bu" 4
Variables may be defined anywhere before they are used, rather than
just at the beginning of a scope as in C. (That is, we adopt the \*(C+
rules that govern where variable declarations are allowed.)
Variables may not be redeclared within the same scope.
.IP "\(bu" 4
Vector constructors, such as the form \f(CW\*(C`float4(1,2,3,4)\*(C'\fR, and
matrix constructors may be used anywhere in an expression.
.IP "\(bu" 4
A \f(CW\*(C`struct\*(C'\fR definition automatically performs a corresponding \f(CW\*(C`typedef\*(C'\fR,
as in \*(C+.
.IP "\(bu" 4
\&\*(C+\-style \f(CW\*(C`//\*(C'\fR comments are allowed in addition to C\-style
\&\f(CW\*(C`/*\*(C'\fR ... \f(CW\*(C`*/\*(C'\fR comments.
.IP "\(bu" 4
A limited form of inheritance is supported;  \f(CW\*(C`interface\*(C'\fR types may be
defined which contain only member functions (no data members) and \f(CW\*(C`struct\*(C'\fR
types may inherit from a single interface and provide specific implementations
for all the member functions.  Interface objects may not be created; a
variable of interface type may have any implementing struct type assigned
to it.
.SH "Detailed Language Specification"
.IX Header "Detailed Language Specification"
.Sh "Definitions"
.IX Subsection "Definitions"
The following definitions are based on the \s-1ANSI\s0 C standard:
.IP "Object" 4
.IX Item "Object"
An object is a region of data storage in the execution
environment, the contents of which can represent values. When
referenced, an object may be interpreted as having a particular
type.
.IP "Declaration" 4
.IX Item "Declaration"
A declaration specifies the interpretation and attributes of a set
of identifiers.
.IP "Definition" 4
.IX Item "Definition"
A declaration that also causes storage to be reserved for an
object or code that will be generated for a function named by an
identifier is a definition.
.Sh "Profiles"
.IX Subsection "Profiles"
Compilation of a Cg program, a top-level function, always occurs in
the context of a compilation profile.  The profile specifies whether
certain optional language features are supported.  These
optional language features include certain control constructs and
standard library functions.  The compilation profile also defines the
precision of the \f(CW\*(C`float\*(C'\fR, \f(CW\*(C`half\*(C'\fR, and \f(CW\*(C`fixed\*(C'\fR data types, and
specifies whether the \f(CW\*(C`fixed\*(C'\fR and \f(CW\*(C`sampler*\*(C'\fR data types are
fully or only partially supported.  The profile also specifies the environment
in which the program will be run.
The choice of a compilation profile is made externally to the language,
by using a compiler command-line switch, for example.
.PP
The profile restrictions are only applied to the top-level function
that is being compiled and to any variables or functions that it
references, either directly or indirectly.  If a function is present in the
source code, but not called directly or indirectly by the top-level
function, it is free to use capabilities that are not supported
by the current profile.
.PP
The intent of these rules is to allow a single Cg source file to
contain many different top-level functions that are targeted at
different profiles.  The core Cg language specification is
sufficiently complete to allow all of these functions to be parsed.
The restrictions provided by a compilation profile are only needed for
code generation, and are therefore only applied to those functions for
which code is being generated.  This specification uses the word
\&\*(L"program\*(R" to refer to the top-level function, any functions
the top-level function calls, and any global variables or typedef
definitions it references.
.PP
Each profile must have a separate specification that describes its
characteristics and limitations.
.PP
This core Cg specification requires certain minimum capabilities for
all profiles.  In some cases, the core specification distinguishes
between vertex-program and fragment-program profiles, with different
minimum capabilities for each.
.Sh "Declarations and declaration specifiers."
.IX Subsection "Declarations and declaration specifiers."
A Cg program consists of a series of declarations, each of which
declares one or more variables or functions, or declares and defines
a single function.  Each declaration consists of zero or more
declaration specifiers, a type, and one or more declarators.  Some
of the declaration specifiers are the same as those in \s-1ANSI\s0 C;
others are new to Cg
.IP "\fBconst\fR" 4
.IX Item "const"
Marks a variable as a constant that cannot be assigned to within the
program.  Unless this is combined with \f(CW\*(C`uniform\*(C'\fR or \f(CW\*(C`varying\*(C'\fR, the
declarator must include an initializer to give the variable a value.
.IP "\fBextern\fR" 4
.IX Item "extern"
Marks this declaration as solely a declaration and not a definition.
There must be a non\-\f(CW\*(C`extern\*(C'\fR declaration elsewhere in the program.
.IP "\fBin\fR" 4
.IX Item "in"
Only usable on parameter and \f(CW\*(C`varying\*(C'\fR declarations.  Marks the parameter
or varying as an input to the function or program.  Function parameters
with no \f(CW\*(C`in\*(C'\fR, \f(CW\*(C`out\*(C'\fR, or \f(CW\*(C`inout\*(C'\fR specifier are implicitly \f(CW\*(C`in\*(C'\fR
.IP "\fBinline\fR" 4
.IX Item "inline"
Only usable on a function definition.  Tells the compiler that it should
always inline calls to the function if at all possible.
.IP "\fBinout\fR" 4
.IX Item "inout"
Only usable on parameter and \f(CW\*(C`varying\*(C'\fR declarations.  Marks the parameter
or varying as both an input to and an output from the function or program
.IP "\fBstatic\fR" 4
.IX Item "static"
Only usable on global variables.  Marks the variable as 'private' to the
program, and not visible externally.   Cannot be combined with \f(CW\*(C`uniform\*(C'\fR or \f(CW\*(C`varying\*(C'\fR
.IP "\fBout\fR" 4
.IX Item "out"
Only usable on parameter and \f(CW\*(C`varying\*(C'\fR declarations.  Marks the parameter
or varying as an output from the function or program
.IP "\fBuniform\fR" 4
.IX Item "uniform"
Only usable on global variables and parameters to the top-level main function
of a program.  If specified on a non-top-level function parameter it is ignored.
The intent of this rule is to allow
a function to serve as either a top-level function or as one that is not.
.Sp
Note that \f(CW\*(C`uniform\*(C'\fR variables may be read and written just like
non\-\f(CW\*(C`uniform\*(C'\fR variables.  The \f(CW\*(C`uniform\*(C'\fR qualifier simply provides
information about how the initial value of the variable is to be
specified and stored, through a mechanism external to the language.
.IP "\fBvarying\fR" 4
.IX Item "varying"
Only usable on global variables and parameters to the top-level main function
of a program.  If specified on a non-top-level function parameter it is ignored.
.IP "\fBprofile name\fR" 4
.IX Item "profile name"
The name of any profile (or profile wildcard \*(-- see Profiles) may
be used as a specifier on any function declaration.  It defines a function
that is only visible in the corresponding profiles.
.PP
The specifiers \f(CW\*(C`uniform\*(C'\fR and \f(CW\*(C`varying\*(C'\fR specify how data is transferred
between the rest of the world and a Cg program.  
Typically, the initial value of a \f(CW\*(C`uniform\*(C'\fR variable or parameter is stored
in a different class of hardware register for a \f(CW\*(C`varying\*(C'\fR.  Furthermore, the external
mechanism for specifying the initial value of \f(CW\*(C`uniform\*(C'\fR
variables or parameters may be different than that used for specifying
the initial value of \f(CW\*(C`varying\*(C'\fR variables or parameters.  Parameters qualified
as \f(CW\*(C`uniform\*(C'\fR are normally treated as persistent state, while \f(CW\*(C`varying\*(C'\fR
parameters are treated as streaming data, with a new value specified
for each stream record (such as within a vertex array).
.PP
Non\-\f(CW\*(C`static\*(C'\fR global variables are treated as \f(CW\*(C`uniform\*(C'\fR by default, while
parameters to the top-level function are treated as \f(CW\*(C`varying\*(C'\fR by default.
.PP
Each declaration is visible (\*(L"in scope\*(R") from the point of its declarator
until the end of the enclosing block or the end of the compilation unit
if outside any block.  Declarations in named scopes (such as structs and
interfaces) may be visible outside of their scope using explicit scope
qualifiers, as in \*(C+.
.Sh "Semantics"
.IX Subsection "Semantics"
Each declarator in a declaration may optionally have a semantic specified
with it.  A semantic specifies how the variable is connected to the environment
in which the program runs.  All semantics are profile specific (so they
have different meanings in different profiles), though there is some
attempt to be consistent across profiles.  Each profile specification must
specify the set of semantics which the profile understands, as well as
what behavior occurs for any other unspecified semantics.
.Sh "Function Declarations"
.IX Subsection "Function Declarations"
Functions are declared essentially as in C.  A function that does not
return a value must be declared with a \f(CW\*(C`void\*(C'\fR return type.  A function
that takes no parameters may be declared in one of two ways:
.IP "As in C, using the void keyword:" 4
.IX Item "As in C, using the void keyword:"
.Vb 1
\&        functionName(void)
.Ve
.IP "With no parameters at all:" 4
.IX Item "With no parameters at all:"
.Vb 1
\&        functionName()
.Ve
.PP
Functions may be declared as \f(CW\*(C`static\*(C'\fR.  If so, they may not be
compiled as a program and are not visible externally
.Sh "Function overloading and optional arguments"
.IX Subsection "Function overloading and optional arguments"
Cg supports function overloading; that is you may define multiple functions
with the same name.  The function actually called at any given call site
is based on the types of the arguments at that call site; the definition
that best matches is called.  See the function overloading
section for the precise rules.  Trailing arguments with initializers are
optional arguments; defining a function with optional arguments is
equivalent to defining multiple overloaded functions that differ by having
and not having the optional argument.  The value of the initializer is
used only for the version that does not have the argument and is ignored
if the argument is present.
.Sh "Overloading of Functions by Profile"
.IX Subsection "Overloading of Functions by Profile"
Cg supports overloading of functions by compilation profile.  This
capability allows a function to be implemented differently for
different profiles.  It is also useful because different profiles may
support different subsets of the language capabilities, and because
the most efficient implementation of a function may be different for
different profiles.
.PP
The profile name must precede the return type name in the
function declaration. For example, to define two different versions of
the function \f(CW\*(C`myfunc\*(C'\fR for the \f(CW\*(C`profileA\*(C'\fR and \f(CW\*(C`profileB\*(C'\fR profiles:
.PP
.Vb 2
\&        profileA float myfunc(float x) {...};
\&        profileB float myfunc(float x) {...};
.Ve
.PP
If a type is defined (using a \f(CW\*(C`typedef\*(C'\fR) that has the same name as a
profile, the identifier is treated as a type name, and is not
available for profile overloading at any subsequent point in the
file.
.PP
If a function definition does not include a profile, the function
is referred to as an \*(L"open-profile\*(R" function.  Open-profile functions
apply to all profiles.
.PP
Several wildcard profile names are defined.  The name \f(CW\*(C`vs\*(C'\fR matches any
vertex profile, while the name \f(CW\*(C`ps\*(C'\fR matches any fragment or pixel profile.
The names \f(CW\*(C`ps_1\*(C'\fR and \f(CW\*(C`ps_2\*(C'\fR match any \s-1DX8\s0 pixel shader 1.x profile,
or \s-1DX9\s0 pixel shader 2.x profile, respectively.
Similarly, the names \f(CW\*(C`vs_1\*(C'\fR and \f(CW\*(C`vs_2\*(C'\fR match any \s-1DX\s0 vertex
shader 1.x or 2.x, respectively.  Additional valid wildcard profile
names may be defined by individual profiles.
.PP
In general, the most specific version of a function is used.
More details are provided in the section on function overloading,
but roughly speaking, the search order is the following:
.IP "1." 4
version of the function with the exact profile overload
.IP "2." 4
version of the function with the most specific wildcard profile overload (e.g.  \f(CW\*(C`vs\*(C'\fR, \*(L"ps_1\*(R")
.IP "3." 4
version of function with no profile overload
.PP
This search process allows generic versions of a function to be
defined that can be overridden as needed for particular hardware.
.Sh "Syntax for Parameters in Function Definitions"
.IX Subsection "Syntax for Parameters in Function Definitions"
Functions are declared in a manner similar to C, but the parameters
in function definitions may include a binding semantic (discussed
later) and a default value.
.PP
Each parameter in a function definition takes the following form:
.PP
.Vb 1
\&  <declspecs> <type> identifier [: <binding_semantic>] [= <default>]
.Ve
.PP
\&\fI <default\fR > is an expression that resolves to a constant at compile time.
.PP
Default values are only permitted for \f(CW\*(C`uniform\*(C'\fR parameters, and for
\&\f(CW\*(C`in\*(C'\fR parameters to non top-level functions.
.Sh "Function Calls"
.IX Subsection "Function Calls"
A function call returns an rvalue. Therefore, if a function returns an
array, the array may be read but not written. For example, the following
is allowed:
.PP
.Vb 1
\&        y = myfunc(x)[2];
.Ve
.PP
But, this is not:
.PP
.Vb 1
\&        myfunc(x)[2] = y;
.Ve
.PP
For multiple function calls within an expression, the calls can occur
in any order\*(--it is undefined.
.Sh "Types"
.IX Subsection "Types"
Cg's types are as follows:
.IP "\(bu" 4
The \f(CW\*(C`int\*(C'\fR type is preferably 32\-bit two's complement.  Profiles may
optionally treat \f(CW\*(C`int\*(C'\fR as \f(CW\*(C`float\*(C'\fR.
.IP "\(bu" 4
The \f(CW\*(C`unsigned\*(C'\fR type is preferably a 32\-bit ordinal value.  \f(CW\*(C`unsigned\*(C'\fR
may also be used with other integer types to make different sized unsigned
values
.IP "\(bu" 4
The \f(CW\*(C`char\*(C'\fR, \f(CW\*(C`short\*(C'\fR, and \f(CW\*(C`long\*(C'\fR types are two's complement integers of
various sizes.  The only requirement is that \f(CW\*(C`char\*(C'\fR is no larger that \f(CW\*(C`short\*(C'\fR,
\&\f(CW\*(C`short\*(C'\fR is no larger than \f(CW\*(C`int\*(C'\fR and \f(CW\*(C`long\*(C'\fR is at least as large as \f(CW\*(C`int\*(C'\fR
.IP "\(bu" 4
The \f(CW\*(C`float\*(C'\fR type is as close as possible to the \s-1IEEE\s0 single precision
(32\-bit) floating point format. Profiles must support the \f(CW\*(C`float\*(C'\fR
data type.
.IP "\(bu" 4
The \f(CW\*(C`half\*(C'\fR type is lower-precision IEEE-like floating point.
Profiles must support the \f(CW\*(C`half\*(C'\fR type, but may choose to implement
it with the same precision as the \f(CW\*(C`float\*(C'\fR type.
.IP "\(bu" 4
The \f(CW\*(C`fixed\*(C'\fR type is a signed type with a range of at least [\-2,2) and
with at least 10 bits of fractional precision.
Overflow operations on the data type clamp rather than wrap.
Fragment profiles must support the \f(CW\*(C`fixed\*(C'\fR type, but may
implement it with the same precision as the \f(CW\*(C`half\*(C'\fR or \f(CW\*(C`float\*(C'\fR types.
Vertex profiles are required to provide partial support
(as defined below) for the \f(CW\*(C`fixed\*(C'\fR type.
Vertex profiles have the option to provide full support for the \f(CW\*(C`fixed\*(C'\fR
type or to implement the \f(CW\*(C`fixed\*(C'\fR type with the same precision as
the \f(CW\*(C`half\*(C'\fR or \f(CW\*(C`float\*(C'\fR types.
.IP "\(bu" 4
The \f(CW\*(C`bool\*(C'\fR type represents Boolean values.
Objects of \f(CW\*(C`bool\*(C'\fR type are either true or false.
.IP "\(bu" 4
The \f(CW\*(C`cint\*(C'\fR type is 32\-bit two's complement.  This type is meaningful
only at compile time; it is not possible to declare objects of type
\&\f(CW\*(C`cint\*(C'\fR.
.IP "\(bu" 4
The \f(CW\*(C`cfloat\*(C'\fR type is \s-1IEEE\s0 single-precision (32\-bit) floating
point.  This type is meaningful only at compile time; it is not
possible to declare objects of type \f(CW\*(C`cfloat\*(C'\fR.
.IP "\(bu" 4
The \f(CW\*(C`void\*(C'\fR type may not be used in any expression.  It may only be
used as the return type of functions that do not return a value.
.IP "\(bu" 4
The \f(CW\*(C`sampler*\*(C'\fR types are handles to texture objects.  Formal
parameters of a program or function may be of type \f(CW\*(C`sampler*\*(C'\fR.  No
other definition of \f(CW\*(C`sampler*\*(C'\fR variables is permitted.  A \f(CW\*(C`sampler*\*(C'\fR
variable may only be used by passing it to another function as an
\&\f(CW\*(C`in\*(C'\fR parameter.  Assignment to \f(CW\*(C`sampler*\*(C'\fR variables is not
permitted, and \f(CW\*(C`sampler*\*(C'\fR expressions are not permitted.
.Sp
The following sampler types are always defined:
\&\f(CW\*(C`sampler\*(C'\fR, \f(CW\*(C`sampler1D\*(C'\fR, \f(CW\*(C`sampler2D\*(C'\fR, \f(CW\*(C`sampler3D\*(C'\fR, \f(CW\*(C`samplerCUBE\*(C'\fR,
\&\f(CW\*(C`samplerRECT\*(C'\fR.
.Sp
The base \f(CW\*(C`sampler\*(C'\fR type may be used in any context in which
a more specific sampler type is valid.  However, a \f(CW\*(C`sampler\*(C'\fR
variable must be used in a consistent way throughout the program.
For example, it cannot be used in place of both a \f(CW\*(C`sampler1D\*(C'\fR
and a \f(CW\*(C`sampler2D\*(C'\fR in the same program.   The \f(CW\*(C`sampler\*(C'\fR type is
deprecated and only provided for backwards compatibility with Cg 1.0
.Sp
Fragment profiles are required to fully support the \f(CW\*(C`sampler\*(C'\fR,
\&\f(CW\*(C`sampler1D\*(C'\fR, \f(CW\*(C`sampler2D\*(C'\fR, \f(CW\*(C`sampler3D\*(C'\fR, and \f(CW\*(C`samplerCUBE\*(C'\fR data types.
Fragment profiles are required to provide partial support
(as defined below) for the \f(CW\*(C`samplerRECT\*(C'\fR data type and
may optionally provide full support for this data type.
.Sp
Vertex profiles are required to provide partial support for
the six sampler data types and may optionally provide full
support for these data types.
.IP "\(bu" 4
An \fIarray\fR type is a collection of one or more elements of the same
type.  An \fIarray\fR variable has a single index.
.IP "\(bu" 4
Some array types may be optionally designated as \f(CW\*(C`packed\*(C'\fR, using the
\&\f(CW\*(C`packed\*(C'\fR type modifier.  The storage format of a \f(CW\*(C`packed\*(C'\fR type may
be different from the storage format of the corresponding unpacked
type.  The storage format of packed types is implementation
dependent, but must be consistent for any particular
combination of compiler and profile.  The operations supported on a packed
type in a particular profile may be different than the operations
supported on the corresponding unpacked type in that same profile.
Profiles may define a maximum allowable size for packed arrays, but must
support at least size 4 for packed vector (1D array) types,
and 4x4 for packed matrix (2D array) types.
.IP "\(bu" 4
When declaring an array of arrays in a single declaration, the
\&\f(CW\*(C`packed\*(C'\fR modifier refers to all of the arrays.  However, it is
possible to declare an unpacked array of \f(CW\*(C`packed\*(C'\fR arrays by declaring
the first level of array in a \f(CW\*(C`typedef\*(C'\fR using the \f(CW\*(C`packed\*(C'\fR keyword
and then declaring an array of this type in a second
statement.  It is not possible to declare a packed array of unpacked
arrays.
.IP "\(bu" 4
For any supported numeric data type \fI\s-1TYPE\s0\fR, implementations
must support the following packed array types, which are called
\&\fIvector types\fR.
Type identifiers must be predefined for these types
in the global scope:
.Sp
.Vb 4
\&        typedef packed TYPE TYPE1[1];
\&        typedef packed TYPE TYPE2[2];
\&        typedef packed TYPE TYPE3[3];
\&        typedef packed TYPE TYPE4[4];
.Ve
.Sp
For example, implementations must predefine the type identifiers
\&\f(CW\*(C`float1\*(C'\fR, \f(CW\*(C`float2\*(C'\fR, \f(CW\*(C`float3\*(C'\fR, \f(CW\*(C`float4\*(C'\fR, and so on for any other
supported numeric type.
.IP "\(bu" 4
For any supported numeric data type \fI\s-1TYPE\s0\fR, implementations must
support the following packed array types, which are called \fImatrix types\fR.
Implementations must also predefine type identifiers (in the
global scope) to represent these types:
.Sp
.Vb 10
\&        packed TYPE1 TYPE1x1[1];
\&        packed TYPE2 TYPE1x2[1];
\&        packed TYPE3 TYPE1x3[1];
\&        packed TYPE4 TYPE1x4[1];
\&        packed TYPE1 TYPE2x1[2];
\&        packed TYPE2 TYPE2x2[2];
\&        packed TYPE3 TYPE2x3[2];
\&        packed TYPE4 TYPE2x4[2];
\&        packed TYPE1 TYPE3x1[3];
\&        packed TYPE2 TYPE3x2[3];
\&        packed TYPE3 TYPE3x3[3];
\&        packed TYPE4 TYPE3x4[3];
\&        packed TYPE1 TYPE4x1[4];
\&        packed TYPE2 TYPE4x2[4];
\&        packed TYPE3 TYPE4x3[4];
\&        packed TYPE4 TYPE4x4[4];
.Ve
.Sp
For example, implementations must predefine the type identifiers
\&\f(CW\*(C`float2x1\*(C'\fR, \f(CW\*(C`float3x3\*(C'\fR, \f(CW\*(C`float4x4\*(C'\fR, and so on.  A typedef
follows the usual matrix-naming convention of \f(CW\*(C`TYPErows_X_columns\*(C'\fR.
If we declare \f(CW\*(C`float4x4 a\*(C'\fR, then
.Sp
.Vb 1
\&        a[3] is equivalent to a._m30_m31_m32_m33
.Ve
.Sp
Both expressions extract the third row of the matrix.
.IP "\(bu" 4
Implementations are required to support indexing of vectors and matrices
with constant indices.
.IP "\(bu" 4
A \f(CW\*(C`struct\*(C'\fR type is a collection of one or more members of possibly
different types.  It may include both function members (methods) and
data members (fields).
.Sh "Struct and Interface types"
.IX Subsection "Struct and Interface types"
Interface types are defined with a \fIinterface\fR keyword in place of
the normal \fIstruct\fR keyword.  Interface types may only declare
member functions, not data members.  Interface member functions may
only be declared, not defined (no default implementations in \*(C+ parlance).
.PP
Struct types may inherit from a single interface type, and must define
an implementation member function for every member function declared in
the interface type.
.Sh "Partial Support of Types"
.IX Subsection "Partial Support of Types"
This specification mandates \*(L"partial support\*(R" for some types.
Partial support for a type requires the following:
.IP "\(bu" 4
Definitions and declarations using the type are supported.
.IP "\(bu" 4
Assignment and copy of objects of that type are supported
(including implicit copies when passing function parameters).
.IP "\(bu" 4
Top-level function parameters may be defined using that type.
.PP
If a type is partially supported, variables may be defined using
that type but no useful operations can be performed on them.
Partial support for types makes it easier to share
data structures in code that is targeted at different profiles.
.Sh "Type Categories"
.IX Subsection "Type Categories"
.IP "\(bu" 4
The \fIsigned integral\fR type category includes types \f(CW\*(C`cint\*(C'\fR, \f(CW\*(C`char\*(C'\fR, \f(CW\*(C`short\*(C'\fR, \f(CW\*(C`int\*(C'\fR, and \f(CW\*(C`long\*(C'\fR.
.IP "\(bu" 4
The \fIunsigned integral\fR type category includes types \f(CW\*(C`unsigned char\*(C'\fR, \f(CW\*(C`unsigned short\*(C'\fR, \f(CW\*(C`unsigned int\*(C'\fR, and \f(CW\*(C`unsigned long\*(C'\fR.  \f(CW\*(C`unsigned\*(C'\fR is the same as \f(CW\*(C`unsigned int\*(C'\fR
.IP "\(bu" 4
The \fIintegral\fR category includes both \fIsigned integral\fR and \fIunsigned integral\fR types
.IP "\(bu" 4
The \fIfloating\fR type category includes types \f(CW\*(C`cfloat\*(C'\fR, \f(CW\*(C`float\*(C'\fR, \f(CW\*(C`half\*(C'\fR,
and \f(CW\*(C`fixed\*(C'\fR  (Note that floating really means floating or
fixed/fractional.)
.IP "\(bu" 4
The \fInumeric\fR type category includes \fIintegral\fR and \fIfloating\fR types.
.IP "\(bu" 4
The \fIcompile-time\fR type category includes types \f(CW\*(C`cfloat\*(C'\fR and \f(CW\*(C`cint\*(C'\fR.
These types are used by the compiler for constant type conversions.
.IP "\(bu" 4
The \fIdynamic\fR type category includes all interface
and unsized array types
.IP "\(bu" 4
The \fIconcrete\fR type category includes all types that are not included
in the \fIcompile-time\fR and \fIdynamic\fR type category.
.IP "\(bu" 4
The \fIscalar\fR type category includes all types in the numeric
category, the \f(CW\*(C`bool\*(C'\fR type, and all types in the compile-time category.
In this specification, a reference to a \fIcategory\fR type (such as a reference
to a numeric type) means one of the types included in the category
(such as \f(CW\*(C`float\*(C'\fR, \f(CW\*(C`half\*(C'\fR, or \f(CW\*(C`fixed\*(C'\fR).
.Sh "Constants"
.IX Subsection "Constants"
Constant literals are defined as in C, including an optional \f(CW0\fR or
\&\f(CW\*(C`0x\*(C'\fR prefix for octal or hexadecimal constants, and \f(CW\*(C`e\*(C'\fR exponent
suffix for floating point constants. A constant may be explicitly typed or
implicitly typed.  Explicit typing of a constant is performed, as in C,
by suffixing the constant with a one or two characters indicating the
type of the constant:
.IP "\(bu" 4
\&\fBd\fR for \f(CW\*(C`double\*(C'\fR
.IP "\(bu" 4
\&\fBf\fR for \f(CW\*(C`float\*(C'\fR
.IP "\(bu" 4
\&\fBh\fR for \f(CW\*(C`half\*(C'\fR
.IP "\(bu" 4
\&\fBi\fR for \f(CW\*(C`int\*(C'\fR
.IP "\(bu" 4
\&\fBl\fR for \f(CW\*(C`long\*(C'\fR
.IP "\(bu" 4
\&\fBs\fR for \f(CW\*(C`short\*(C'\fR
.IP "\(bu" 4
\&\fBt\fR for \f(CW\*(C`char\*(C'\fR
.IP "\(bu" 4
\&\fBu\fR for \f(CW\*(C`unsigned\*(C'\fR, which may also be followed by \fBs\fR, \fBt\fR, \fBi\fR, or \fBl\fR
.IP "\(bu" 4
\&\fBx\fR for \f(CW\*(C`fixed\*(C'\fR
.PP
Any constant that is not explicitly typed is implicitly typed.  If the
constant includes a decimal point or an 'e' exponent suffix, it is
implicitly typed as \f(CW\*(C`cfloat\*(C'\fR. If it does not include a decimal point,
it is implicitly typed as \f(CW\*(C`cint\*(C'\fR.
.PP
By default, constants are base 10.  For compatibility with C,
integer hexadecimal constants may be specified by prefixing the constant with
\&\f(CW\*(C`0x\*(C'\fR, and integer octal constants may be specified by prefixing the constant
with \f(CW0\fR.
.PP
Compile-time constant folding is preferably performed at the same precision
that would be used if the operation were performed at run time. Some
compilation profiles may allow some precision flexibility for the
hardware; in such cases the compiler should ideally perform the constant
folding at the highest hardware precision allowed for that data type
in that profile.
.PP
If constant folding cannot be performed at run-time precision,
it may optionally be performed using the precision indicated below
for each of the numeric datatypes:
.IP "float" 4
.IX Item "float"
s23e8 (\*(L"fp32\*(R") \s-1IEEE\s0 single precision floating point
.IP "half" 4
.IX Item "half"
s10e5 (\*(L"fp16\*(R") floating point w/ \s-1IEEE\s0 semantics
.IP "fixed" 4
.IX Item "fixed"
S1.10 fixed point, clamping to [\-2, 2)
.IP "double" 4
.IX Item "double"
s52e11 (\*(L"fp64\*(R") \s-1IEEE\s0 double precision floating point
.IP "int" 4
.IX Item "int"
signed 32 bit twos-complement integer
.IP "char" 4
.IX Item "char"
signed 8 bit twos-complement integer
.IP "short" 4
.IX Item "short"
signed 16 bit twos-complement integer
.IP "long" 4
.IX Item "long"
signed 64 bit twos-complement integer
.Sh "Type Conversions"
.IX Subsection "Type Conversions"
Some type conversions are allowed implicitly, while others require an
cast.  Some implicit conversions may cause a warning, which can be
suppressed by using an explicit cast.  Explicit casts are indicated
using C\-style syntax (e.g., casting \f(CW\*(C`variable\*(C'\fR to the \f(CW\*(C`float4\*(C'\fR type
may be achieved via \*(L"(float4)variablename\*(R").
.IP "Scalar conversions" 4
.IX Item "Scalar conversions"
Implicit conversion of any scalar numeric type to any other scalar
numeric type is allowed.  A warning may be issued if the conversion
is implicit and it is possible that precision is lost.
implicit conversion of any scalar object type to any compatible scalar
object type is also allowed.  Conversions between incompatible scalar
object types or object and numeric types are not allowed, even with
an explicit cast.
\&\*(L"sampler\*(R" is compatible with \*(L"sampler1D\*(R", \*(L"sampler2D\*(R", \*(L"sampler3D\*(R",
\&\*(L"samplerCube\*(R", and \*(L"samplerRECT\*(R".  No other object types are compatible
(\*(L"sampler1D\*(R" is not compatible with \*(L"sampler2D\*(R", even though both
are compatible with \*(L"sampler\*(R").
.Sp
Scalar types may be implicitly converted to vectors and matrixes of
compatible type.  The scalar will be replicated to all elements of
the vector or matrix.  Scalar types may also be explicitly cast to
structure types if the scalar type can be legally cast to every
member of the structure.
.IP "Vector conversions" 4
.IX Item "Vector conversions"
Vectors may be converted to scalar types (selects the first element
of the vector).  A warning is issued if this is done implicitly.  A
vector may also be implicitly converted to another vector of the same
size and compatible element type.
.Sp
A vector may be converted to a smaller compatible vector, or a matrix
of the same total size, but a warning if issued if an explicit cast is
not used.
.IP "Matrix conversions" 4
.IX Item "Matrix conversions"
Matrixes may be converted to a scalar type (selects to 0,0 element).
As with vectors, this causes a warning if its done implicitly.  A
matrix may also be converted implicitly to a matrix of the same size
and shape and compatible element type
.Sp
A Matrix may be converted to a smaller matrix type (selects the upper\-
left submatrix), or to a vector of the same total size, but a warning
is issued if an explicit cast is not used.
.IP "Structure conversions" 4
.IX Item "Structure conversions"
a structure may be explicitly cast to the type of its first member, or
to another structure type with the same number of members, if each
member of the struct can be converted to the corresponding member of
the new struct.  No implicit conversions of struct types are allowed.
.IP "Array conversions" 4
.IX Item "Array conversions"
An array may be explicitly converted to another array type
with the same number of elements and a compatible element type.
A compatible element type is any type to which the element type
of the initial array may be implicitly converted to.  No implicit
conversions of array types are allowed.
.Sp
.Vb 10
\&                                    Source type
\&           | Scalar | Vector | Matrix | Struct | Array  |
\& T    \-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+
\& a  Scalar |   A    |   W    |   W    |  E(3)  |   \-    |
\& r    \-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+
\& g  Vector |   A    | A/W(1) |  W(2)  |  E(3)  |  E(6)  |
\& e    \-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+
\& t  Matrix |   A    |  W(2)  | A/W(1) |  E(3)  |  E(7)  |
\&      \-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+
\& t  Struct |   E    |  E(4)  |  E(4)  | E(4/5) |  E(4)  |
\& y    \-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+
\& p  Array  |   \-    |  E(6)  |  E(7)  |  E(3)  |  E(6)  |
\& e    \-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+
\&
\&     A = allowed implicitly or explicitly
\&     W = allowed, but warning issued if implicit
\&     E = only allowed with explicit cast
\&     \- = not allowed
\& notes
\&   (1) not allowed if target is larger than source.  Warning if
\&       target is smaller than source
\&   (2) only allowed if source and target are the same total size
\&   (3) only if the first member of the source can be converted to
\&       the target
\&   (4) only if the target struct contains a single field of the
\&       source type
\&   (5) only if both source and target have the same number of
\&       members and each member of the source can be converted
\&       to the corresponding member of the target.
\&   (6) Source and target sizes must be the same and element types
\&       must be compatible
\&   (7) Array type must be an array of vectors that matches the
\&       matrix type.
.Ve
.PP
Explicit casts are:
.IP "\(bu" 4
compile-time type when applied to expressions of compile-time type.
.IP "\(bu" 4
numeric type when applied to expressions of numeric or compile-time types.
.IP "\(bu" 4
numeric vector type when applied to another vector type of the same number of elements.
.IP "\(bu" 4
numeric matrix type when applied to another matrix type of the same
  number of rows and columns.
.Sh "Type Equivalency"
.IX Subsection "Type Equivalency"
Type T1 is equivalent to type T2 if any of the following are true:
.IP "\(bu" 4
T2 is equivalent to T1.
.IP "\(bu" 4
T1 and T2 are the same scalar, vector, or structure type.
A packed array type is \fInot\fR equivalent to the same size unpacked array.
.IP "\(bu" 4
T1 is a typedef name of T2.
.IP "\(bu" 4
T1 and T2 are arrays of equivalent types with the same number of
elements.
.IP "\(bu" 4
The unqualified types of T1 and T2 are equivalent, and both types have
the same qualifications.
.IP "\(bu" 4
T1 and T2 are functions with equivalent return types, the same
number of parameters, and all corresponding parameters are
pair-wise equivalent.
.Sh "Type-Promotion Rules"
.IX Subsection "Type-Promotion Rules"
The \f(CW\*(C`cfloat\*(C'\fR and \f(CW\*(C`cint\*(C'\fR types behave like \f(CW\*(C`float\*(C'\fR and \f(CW\*(C`int\*(C'\fR types, except for the
usual arithmetic conversion behavior (defined below) and
function-overloading rules (defined later).
.PP
The \fIusual arithmetic conversions\fR for binary operators are defined as follows:
.IP "1." 4
If one operand is \f(CW\*(C`cint\*(C'\fR it is converted to the other type
.IP "2." 4
If one operand is \f(CW\*(C`cfloat\*(C'\fR and the other is \fIfloating\fR, the \f(CW\*(C`cfloat\*(C'\fR is converted to the other type
.IP "3." 4
If both operands are \fIfloating\fR then the smaller type is converted to the larger type
.IP "4." 4
If one operand is \fIfloating\fR and the other is \fIintegral\fR, the integral argument is converted to the floating type.
.IP "5." 4
If both operands are \fIintegral\fR the smaller type is converted to the larger type
.IP "6." 4
If one operand is \fIsigned integral\fR while the other is \fIunsigned integral\fR and they are the same size, the signed type is converted to unsigned.
.PP
Note that conversions happen prior to performing the operation.
.Sh "Assignment"
.IX Subsection "Assignment"
Assignment of an expression to a \fIconcrete\fR typed object
converts the expression to the type of the object. The resulting
value is then assigned to the object or value.
.PP
The value of the assignment expressions (\f(CW\*(C`=\*(C'\fR, \f(CW\*(C`*=\*(C'\fR, and so on) is defined as in C:
.PP
An assignment expression has the value of the left operand after the
assignment but is not an lvalue.  The type of an assignment
expression is the type of the left operand unless the left operand has a
qualified type, in which case it is the unqualified version of the
type of the left operand.  The side effect of updating the stored
value of the left operand occurs between the previous and the
next sequence point.
.PP
An assignment of an expression to a \fIdynamic\fR typed object is only
possible if the type of the expression is compatible with the dynamic
object type.  The object will then take on the type of the expression
assigned to it until the next assignment to it.
.ie n .Sh """Smearing"" of Scalars to Vectors"
.if !n .Sh "``Smearing'' of Scalars to Vectors"
.IX Subsection "Smearing of Scalars to Vectors"
If a binary operator is applied to a vector and a scalar, the scalar
is automatically type-promoted to a same-sized vector by replicating
the scalar into each component.  The ternary \f(CW\*(C`?:\*(C'\fR operator also supports
smearing.  The binary rule is applied to the second and third operands
first, and then the binary rule is applied to this result and the first
operand.
.Sh "Namespaces"
.IX Subsection "Namespaces"
Just as in C, there are two namespaces. Each has multiple scopes, as in C.
.IP "\(bu" 4
Tag namespace, which consists of \f(CW\*(C`struct\*(C'\fR tags
.IP "\(bu" 4
Regular namespace:
.RS 4
.IP "\-" 4
typedef names (including an automatic \f(CW\*(C`typedef\*(C'\fR from a \f(CW\*(C`struct\*(C'\fR declaration)
.IP "\-" 4
variables
.IP "\-" 4
function names
.RE
.RS 4
.RE
.Sh "Arrays and Subscripting"
.IX Subsection "Arrays and Subscripting"
Arrays are declared as in C, except that they may optionally be
declared to be \f(CW\*(C`packed\*(C'\fR, as described earlier.  Arrays in Cg are
first-class types, so array parameters to functions and programs must
be declared using array syntax, rather than pointer syntax.  Likewise,
assignment of an \fIarray\fR\-typed object implies an array copy rather than
a pointer copy.
.PP
Arrays with size \f(CW\*(C`[1]\*(C'\fR may be declared but are considered a different
type from the corresponding non-array type.
.PP
Because the language does not currently support pointers, the storage
order of arrays is only visible when an application passes parameters
to a vertex or fragment program.  Therefore, the compiler is currently
free to allocate temporary variables as it sees fit.
.PP
The declaration and use of arrays of arrays is in the same style as in
C.  That is, if the 2D array \f(CW\*(C`A\*(C'\fR is declared as
.PP
.Vb 1
\&        float A[4][4];
.Ve
.PP
then, the following statements are true:
.IP "\(bu" 4
The array is indexed as \f(CW\*(C`A[row][column];\*(C'\fR
.IP "\(bu" 4
The array can be built with a constructor using
.Sp
.Vb 4
\&     float4x4 A = { { A[0][0], A[0][1], A[0][2], A[0][3] },
\&                    { A[1][0], A[1][1], A[1][2], A[1][3] },
\&                    { A[2][0], A[2][1], A[2][2], A[2][3] },
\&                    { A[3][0], A[3][1], A[3][2], A[3][3] } };
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`A[0]\*(C'\fR is equivalent to \f(CW\*(C`float4(A[0][0], A[0][1], A[0][2], A[0][3])\*(C'\fR
.PP
Support must be provided for structs containing arrays.
.PP
\fIUnsized Arrays\fR
.IX Subsection "Unsized Arrays"
.PP
Objects may be declared as \fIunsized\fR arrays by using a declaration with
an empty size \f(CW\*(C`[]\*(C'\fR and no initializer.  If a declarator uses unsized
array syntax with an initializer, it is declared with a concrete (sized)
array type based on the declarator.  Unsized arrays are \fIdynamic\fR typed
objects that take on the size of any array assigned to them.
.PP
\fIMinimum Array Requirements\fR
.IX Subsection "Minimum Array Requirements"
.PP
Profiles are required to provide partial support for certain kinds of
arrays.  This partial support is designed to support vectors and
matrices in all profiles.  For vertex profiles, it is additionally
designed to support arrays of light state (indexed by light number)
passed as uniform parameters, and arrays of skinning matrices passed
as uniform parameters.
.PP
Profiles must support subscripting, copying, size querying and swizzling
of vectors and matrices.  However, subscripting with run-time computed
indices is not required to be supported.
.PP
Vertex profiles must support the following operations for any
non-packed array that is a uniform parameter to the program, or is an
element of a structure that is a uniform parameter to the program.
This requirement also applies when the array is indirectly a uniform
program parameter (that is, it and or the structure containing it has
been passed via a chain of \f(CW\*(C`in\*(C'\fR function parameters).  The three
operations that must be supported are
.IP "\(bu" 4
rvalue subscripting by a run-time computed value or a compile-time
value.
.IP "\(bu" 4
passing the entire array as a parameter to a function, where the
corresponding formal function parameter is declared as \f(CW\*(C`in\*(C'\fR.
.IP "\(bu" 4
querying the size of the array with a \f(CW\*(C`.length\*(C'\fR suffix.
.PP
The following operations are explicitly not required to be supported:
.IP "\(bu" 4
lvalue-subscripting
.IP "\(bu" 4
copying
.IP "\(bu" 4
other operators, including multiply, add, compare, and so on
.PP
Note that when a uniform array is rvalue subscripted, the result is
an expression, and this expression is no longer considered to be a
\&\f(CW\*(C`uniform\*(C'\fR program parameter.  Therefore, if this expression is an array,
its subsequent use must conform to the standard rules for array usage.
.PP
These rules are not limited to arrays of numeric types, and thus imply
support for arrays of struct, arrays of matrices, and arrays of
vectors when the array is a \f(CW\*(C`uniform\*(C'\fR program parameter.  Maximum
array sizes may be limited by the number of available registers or
other resource limits, and compilers are permitted to issue error
messages in these cases.  However, profiles must support sizes of at
least \f(CW\*(C`float arr[8]\*(C'\fR, \f(CW\*(C`float4 arr[8]\*(C'\fR, and \f(CW\*(C`float4x4 arr[4][4]\*(C'\fR.
.PP
Fragment profiles are not required to support any operations on
arbitrarily sized arrays; only support for vectors and matrices is
required.
.Sh "Function Overloading"
.IX Subsection "Function Overloading"
Multiple functions may be defined with the same name, as long as the
definitions can be distinguished by unqualified parameter types and
do not have an open-profile conflict (as described in the section on
open functions).
.PP
Function-matching rules:
.IP "1." 4
Add all visible functions with a matching name in the calling scope to
the set of function candidates.
.IP "2." 4
Eliminate functions whose profile conflicts with the current compilation
profile.
.IP "3." 4
Eliminate functions with the wrong number of formal parameters.
If a candidate function has excess formal parameters, and
each of the excess parameters has a default value, do not eliminate
the function.
.IP "4." 4
If the set is empty, fail.
.IP "5." 4
For each actual parameter expression in sequence (left to right), perform the
following:
.RS 4
.IP "a." 4
.IX Item "a."
If the type of the actual parameter matches the unqualified type
of the corresponding formal parameter in any function in the set,
remove all functions whose corresponding parameter does not
match exactly.
.IP "b." 4
.IX Item "b."
If there is a function with a dynamically typed formal argument which
is compatible with the actual parameter type, remove all functions whose
corresponding parameter is not similarly compatible.
.IP "c." 4
.IX Item "c."
If there is a defined promotion for the type of the actual
parameter to the unqualified type of the formal parameter of any
function, remove all functions for which this is not true
from the set.
.IP "d." 4
.IX Item "d."
If there is a valid implicit cast that converts the type of
the actual parameter to the unqualified type of the formal
parameter of any function, remove all functions for which this
is not true from the set
.IP "e." 4
.IX Item "e."
Fail.
.RE
.RS 4
.RE
.IP "6." 4
Choose a function based on profile:
.RS 4
.IP "a." 4
.IX Item "a."
If there is at least one function with a profile that exactly matches
the compilation profile, discard all functions that don't
exactly match.
.IP "b." 4
.IX Item "b."
Otherwise, if there is at least one function with a wildcard profile that
matches the compilation profile, determine the 'most specific' matching
wildcard profile in the candidate set. Discard all functions except
those with this 'most specific' wildcard profile.  How 'specific' a given
wildcard profile name is relative to a particular profile is determined
by the profile specification.
.RE
.RS 4
.RE
.IP "7." 4
If the number of functions remaining in the set is not one, then fail.
.Sh "Global Variables"
.IX Subsection "Global Variables"
Global variables are declared and used as in C.  Non-static
variables may have a semantic associated with them.  Uniform non-static
variables may have their value set through the run-time \s-1API\s0.
.Sh "Use of Uninitialized Variables"
.IX Subsection "Use of Uninitialized Variables"
It is incorrect for a program to use an uninitialized static or local variable.
However, the compiler is not obligated to detect such errors, even if
it would be possible to do so by compile-time data-flow analysis.  The
value obtained from reading an uninitialized variable is undefined.
This same rule applies to the implicit use of a variable that occurs
when it is returned by a top-level function.  In particular, if a
top-level function returns a \f(CW\*(C`struct\*(C'\fR, and some element of that \f(CW\*(C`struct\*(C'\fR
is never written, then the value of that element is undefined.
.PP
Note: The language designers did not choose to define variables
as being initialized to zero because that would result in a
performance penalty in cases where the compiler is unable to determine
if a variable is properly initialized by the programmer.
.Sh "Preprocessor"
.IX Subsection "Preprocessor"
Cg profiles must support the full \s-1ANSI\s0 C standard preprocessor
capabilities: \f(CW\*(C`#if\*(C'\fR, \f(CW\*(C`#define\*(C'\fR, and so on.  However, while \f(CW\*(C`#include\*(C'\fR
must be supported the mechanism by which the file to be included is
located is implementation defined.
.SH "Overview of Binding Semantics"
.IX Header "Overview of Binding Semantics"
In stream-processing architectures, data packets flow between
different programmable units.  On a \s-1GPU\s0, for example, packets of
vertex data flow from the application to the vertex program.
.PP
Because packets are produced by one program (the application, in this case),
and consumed by another (the vertex program), there must be some
mechanism for defining the interface between the two.  Cg
allows the user to choose between two different approaches to defining
these interfaces.
.PP
The first approach is to associate a binding semantic with each
element of the packet.  This approach is a \fIbind-by-name\fR approach.  For
example, an output with the binding semantic \f(CW\*(C`FOO\*(C'\fR is fed to an input
with the binding semantic \f(CW\*(C`FOO\*(C'\fR.  Profiles may allow the user to
define arbitrary identifiers in this \*(L"semantic namespace\*(R", or they may
restrict the allowed identifiers to a predefined set.  Often, these
predefined names correspond to the names of hardware registers or \s-1API\s0
resources.
.PP
In some cases, predefined names may control non-programmable parts of
the hardware.  For example, vertex programs normally compute a
position that is fed to the rasterizer, and this position is stored in
an output with the binding semantic \f(CW\*(C`POSITION\*(C'\fR.
.PP
For any profile, there are two namespaces for predefined
binding semantics\*(--the namespace used for \f(CW\*(C`in\*(C'\fR variables and the
namespace used for \f(CW\*(C`out\*(C'\fR variables.  The primary implication of having
two namespaces is that the binding semantic cannot be used to
implicitly specify whether a variable is \f(CW\*(C`in\*(C'\fR or \f(CW\*(C`out\*(C'\fR.
.PP
The second approach to defining data packets is to describe the data
that is present in a packet and allow the compiler to decide how to
store it.  In Cg, the user can describe the contents of a data packet
by placing all of its contents into a \f(CW\*(C`struct\*(C'\fR.  When a \f(CW\*(C`struct\*(C'\fR is used
in this manner, we refer to it as a \fIconnector\fR.  The two approaches
are not mutually exclusive, as is discussed later.
The connector approach allows the user to rely on a combination of
user-specified semantic bindings and compiler-determined bindings.
.Sh "Binding Semantics"
.IX Subsection "Binding Semantics"
A binding semantic may be associated with an input to a top-level
function or a global variable in one of three ways:
.IP "\(bu" 4
The binding semantic is specified in the formal parameter
declaration for the function. The syntax for formal parameters to a
function is:
.Sp
.Vb 1
\&        [const] [in | out | inout] <type> <identifier> [: <binding\-semantic>] [= <initializer>];
.Ve
.IP "\(bu" 4
If the formal parameter is a \f(CW\*(C`struct\*(C'\fR, the binding semantic may be
specified with an element of the \f(CW\*(C`struct\*(C'\fR when the \f(CW\*(C`struct\*(C'\fR is
defined:
.Sp
.Vb 4
\&        struct <struct\-tag> {
\&            <type> <identifier>[ : <binding\-semantic>];
\&              ...
\&        };
.Ve
.IP "\(bu" 4
If the input to the function is implicit (a non-static global variable
that is read by the function), the binding semantic may be specified
when the non-static global variable is declared:
.Sp
.Vb 1
\&        [varying [in | out]] <type> <identifier> [ : <binding\-semantic>];
.Ve
.Sp
If the non-static global variable is a \f(CW\*(C`struct,\*(C'\fR the binding semantic may
be specified when the \f(CW\*(C`struct\*(C'\fR is defined, as described in the second bullet above.
.IP "\(bu" 4
A binding semantic may be associated with the output of a top-level
function in a similar manner:
.Sp
.Vb 3
\&        <type> <identifier> ( <parameter\-list> ) [: <binding\-semantic>]
\&        {
\&                :
.Ve
.PP
Another method available for specifying a semantic for an output value
is to return a \f(CW\*(C`struct\*(C'\fR, and to specify the binding semantic(s) with
elements of the \f(CW\*(C`struct\*(C'\fR when the \f(CW\*(C`struct\*(C'\fR is defined.  In addition, if
the output
is a formal parameter, then the binding semantic may be specified
using the same approach used to specify binding semantics for inputs.
.Sh "Aliasing of Semantics"
.IX Subsection "Aliasing of Semantics"
Semantics must honor a copy-on-input and copy-on-output model.  Thus,
if the same input binding semantic is used for two different
variables, those variables are initialized with the same value,
but the variables are not aliased thereafter.  Output aliasing is
illegal, but implementations are not required to detect it.  If the
compiler does not issue an error on a program that aliases output
binding semantics, the results are undefined.
.Sh "Additional Details for Binding Semantics"
.IX Subsection "Additional Details for Binding Semantics"
The following are somewhat redundant, but provide extra clarity:
.IP "\(bu" 4
Semantic names are case-insensitive.
.IP "\(bu" 4
Semantics attached to parameters to non-main functions are ignored.
.IP "\(bu" 4
Input semantics may be aliased by multiple variables.
.IP "\(bu" 4
Output semantics may not be aliased.
.Sh "Using a Structure to Define Binding Semantics (Connectors)"
.IX Subsection "Using a Structure to Define Binding Semantics (Connectors)"
Cg profiles may optionally allow the user to avoid the requirement
that a binding semantic be specified for every non-uniform input (or
output) variable to a top-level program.  To avoid this requirement,
all the non-uniform variables should be included within a single
\&\f(CW\*(C`struct\*(C'\fR.  The compiler automatically allocates the elements of this
structure to hardware resources in a manner that allows any program
that returns this \f(CW\*(C`struct\*(C'\fR to interoperate with any program that uses
this \f(CW\*(C`struct\*(C'\fR as an input.
.PP
It is not \fIrequired\fR that all non-uniform inputs be included
within a single struct in order to omit binding semantics.  Binding
semantics may be omitted from any input or output, and the compiler
 performs automatic allocation of that input or output to a
hardware resource.  However, to guarantee interoperability of one
program's output with another program's input when automatic binding
is performed, it is necessary to put all of the variables in a single
\&\f(CW\*(C`struct\*(C'\fR.
.PP
It is permissible to explicitly specify a binding semantic for some
elements of the \f(CW\*(C`struct\*(C'\fR, but not others.  The compiler's automatic
allocation must honor these explicit bindings.  The allowed set of
explicitly specified binding semantics is defined by the
allocation-rule identifier.  The most common use of this capability is
to bind variables to hardware registers that write to, or read from,
non-programmable parts of the hardware.  For example, in a typical
vertex-program profile, the output \f(CW\*(C`struct\*(C'\fR would contain an element
with an explicitly specified \s-1POSITION\s0 semantic.  This element is used
to control the hardware rasterizer.
.Sh "Defining Binding Semantics via an external \s-1API\s0"
.IX Subsection "Defining Binding Semantics via an external API"
It may be possible to define binding semantics on inputs and outputs
by using an external \s-1API\s0 that manipulates the programs environment.
The Cg Runtime \s-1API\s0 is such an \s-1API\s0 that allows this, and others may
exist.
.SH "How Programs Receive and Return Data"
.IX Header "How Programs Receive and Return Data"
A program is a non-static function that has been designated as the
main entry point at compilation time.  The varying inputs to the
program come from this top-level function's varying \f(CW\*(C`in\*(C'\fR parameters,
and any global varying variables that do not have an \f(CW\*(C`out\*(C'\fR modifier.
The uniform inputs to the program come from the top-level function's
uniform \f(CW\*(C`in\*(C'\fR parameters and from any non-static global variables that
are referenced by the top-level function or by any functions that it
calls.  The output of the program comes from the return value of the
function (which is always implicitly varying), from any \f(CW\*(C`out\*(C'\fR
parameters, which must also be varying, and from any \f(CW\*(C`varying out\*(C'\fR global
variables that are written by the program.
.PP
Parameters to a program of type \f(CW\*(C`sampler*\*(C'\fR are implicitly \f(CW\*(C`const\*(C'\fR.
.SH "Statements and Expressions"
.IX Header "Statements and Expressions"
Statements are expressed just as in C, unless an exception is stated
elsewhere in this document. Additionally,
.IP "\(bu" 4
\&\f(CW\*(C`if\*(C'\fR, \f(CW\*(C`while\*(C'\fR, and \f(CW\*(C`for\*(C'\fR require bool expressions in the appropriate
places.
.IP "\(bu" 4
Assignment is performed using \f(CW\*(C`=\*(C'\fR.
The assignment operator returns a value, just as in C, so assignments
may be chained.
.IP "\(bu" 4
The new \f(CW\*(C`discard\*(C'\fR statement terminates execution of the program for the
current data element (such as the current vertex or current fragment) and
suppresses its output. Vertex profiles may choose to
omit support for \f(CW\*(C`discard\*(C'\fR.
.Sh "Minimum Requirements for if, while, for"
.IX Subsection "Minimum Requirements for if, while, for"
The minimum requirements are as follows:
.IP "\(bu" 4
All profiles should support \f(CW\*(C`if\*(C'\fR,
but such support is not strictly required for older hardware.
.IP "\(bu" 4
All profiles should support \f(CW\*(C`for\*(C'\fR and \f(CW\*(C`while\*(C'\fR loops if the number
of loop iterations can be determined at compile time.
\&\*(L"Can be determined at compile time\*(R" is defined as follows:
The loop-iteration expressions can be evaluated at compile time by
use of intra-procedural constant propagation and folding, where the
variables through which constant values are propagated do not
appear as lvalues within any kind of control statement (\f(CW\*(C`if\*(C'\fR, \f(CW\*(C`for\*(C'\fR, or \f(CW\*(C`while\*(C'\fR)
or \f(CW\*(C`?:\*(C'\fR construct.
Profiles may choose to support more general constant propagation
techniques, but such support is not required.
.IP "\(bu" 4
Profiles may optionally support fully general \f(CW\*(C`for\*(C'\fR and \f(CW\*(C`while\*(C'\fR loops.
.Sh "New Vector Operators"
.IX Subsection "New Vector Operators"
These new operators are defined for vector types:
.IP "\(bu" 4
Vector construction operator: \fItypeID\fR\f(CW\*(C`(...)\*(C'\fR:
.Sp
This operator builds a vector from multiple scalars or shorter vectors:
.RS 4
.IP "\-" 4
\&\f(CW\*(C`float4(scalar, scalar, scalar, scalar)\*(C'\fR
.IP "\-" 4
\&\f(CW\*(C`float4(float3, scalar)\*(C'\fR
.RE
.RS 4
.RE
.IP "\(bu" 4
Matrix construction operator: \fItypeID\fR\f(CW\*(C`(...)\*(C'\fR:
.Sp
This operator builds a matrix from multiple rows.
.Sp
Each row may be specified either as multiple scalars or as any
combination of scalars and vectors with the appropriate size, e.g.
.Sp
.Vb 3
\&    float3x3(1, 2, 3, 4, 5, 6, 7, 8, 9)
\&    float3x3(float3, float3, float3)
\&    float3x3(1, float2, float3, 1, 1, 1)
.Ve
.IP "\(bu" 4
Vector swizzle operator: (\f(CW\*(C`.\*(C'\fR)
.Sp
.Vb 1
\&    a = b.xxyz; // A swizzle operator example
.Ve
.RS 4
.IP "\-" 4
At least one swizzle character must follow the operator.
.IP "\-" 4
There are three sets of swizzle characters and they may not be mixed:
Set one is \f(CW\*(C`xyzw = 0123\*(C'\fR, set two is \f(CW\*(C`rgba = 0123\*(C'\fR, and set three is
\&\f(CW\*(C`stpq = 0123\*(C'\fR.
.IP "\-" 4
The vector swizzle operator may only be applied to vectors or to
scalars.
.IP "\-" 4
Applying the vector swizzle operator to a scalar gives the same result as
applying the operator to a vector of length
one. Thus, \f(CW\*(C`myscalar.xxx\*(C'\fR and
\&\f(CW\*(C`float3(myscalar, myscalar, myscalar)\*(C'\fR yield the same value.
.IP "\-" 4
If only one swizzle character is specified, the result is a scalar
not a vector of length one.  Therefore, the expression
\&\f(CW\*(C`b.y\*(C'\fR returns a scalar.
.IP "\-" 4
Care is required when swizzling a constant scalar because of
ambiguity in the use of the decimal point character. For example,
to create a three-vector from a scalar, use one of the following:
\&\f(CW\*(C`(1).xxx\*(C'\fR or \f(CW\*(C`1..xxx\*(C'\fR or \f(CW\*(C`1.0.xxx\*(C'\fR or \f(CW\*(C`1.0f.xxx\*(C'\fR
.IP "\-" 4
The size of the returned vector is determined by the number of
swizzle characters.  Therefore, the size of the result may be larger
or smaller than the size of the original vector.
For example,
\&\f(CW\*(C`float2(0,1).xxyy\*(C'\fR and \f(CW\*(C`float4(0,0,1,1)\*(C'\fR yields the same result.
.RE
.RS 4
.RE
.IP "\(bu" 4
Matrix swizzle operator:
.Sp
For any matrix type of the form '<type><rows>x<columns>', the
notation: '<matrixObject>._m<row><col>[_m<row><col>][...]' can be
used to access individual matrix elements (in the case of only one
<row>,<col> pair) or to construct vectors from elements of a
matrix (in the case of more than one <row>,<col> pair).
The row and column numbers are zero-based.
.Sp
For example:
.Sp
.Vb 3
\&        float4x4 myMatrix;
\&        float    myFloatScalar;
\&        float4   myFloatVec4;
\&
\&        // Set myFloatScalar to myMatrix[3][2]
\&        myFloatScalar = myMatrix._m32;
\&
\&        // Assign the main diagonal of myMatrix to myFloatVec4
\&        myFloatVec4 = myMatrix._m00_m11_m22_m33;
.Ve
.Sp
For compatibility with the D3DMatrix data type, Cg also allows
one-based swizzles, using a form with the \f(CW\*(C`m\*(C'\fR omitted after the \f(CW\*(C`_\*(C'\fR:
\&'<matrixObject>._<row><col>[_<row><col>][...]'  In this
form, the indexes for <row> and <col> are one-based, rather than the
C standard zero-based. So, the two forms are functionally
equivalent:
.Sp
.Vb 2
\&        float4x4 myMatrix;
\&        float4   myVec;
\&
\&        // These two statements are functionally equivalent:
\&        myVec = myMatrix._m00_m23_m11_m31;
\&        myVec = myMatrix._11_34_22_42;
.Ve
.Sp
Because of the confusion that can be caused by the one-based indexing, its
use is strongly discouraged.  Also one-based indexing and zero-based
indexing cannot be mixed in a single swizzle
.Sp
The matrix swizzles may only be applied to matrices.  When multiple
components are extracted from a matrix using a swizzle, the result
is an appropriately sized vector. When a swizzle is used to extract
a single component from a matrix, the result is a scalar.
.IP "\(bu" 4
The write-mask operator: (\f(CW\*(C`.\*(C'\fR)
It can only be applied to an lvalue that is a vector or matrix.
It allows assignment to particular elements of a vector or matrix,
leaving other elements unchanged.  It looks exactly like a swizzle,
with the additional restriction that a component cannot be repeated.
.Sh "Arithmetic Precision and Range"
.IX Subsection "Arithmetic Precision and Range"
Some hardware may not conform exactly to \s-1IEEE\s0 arithmetic rules.
Fixed-point data types do not have IEEE-defined rules.
.PP
Optimizations are permitted to produce slightly different results than
unoptimized code.  Constant folding must be done with approximately
the correct precision and range, but is not required to produce
bit-exact results.  It is recommended that compilers provide an option
either to forbid these optimizations or to guarantee that they are made in
bit-exact fashion.
.Sh "Operator Precedence"
.IX Subsection "Operator Precedence"
Cg uses the same operator precedence as C for operators that are
common between the two languages.
.PP
The swizzle and write-mask operators (\f(CW\*(C`.\*(C'\fR) have the same precedence as the
structure member operator (\f(CW\*(C`.\*(C'\fR) and the array index operator \f(CW\*(C`[]\*(C'\fR.
.Sh "Operator Enhancements"
.IX Subsection "Operator Enhancements"
The standard C arithmetic operators (\f(CW\*(C`+\*(C'\fR, \f(CW\*(C`\-\*(C'\fR, \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`/\*(C'\fR, \f(CW\*(C`%\*(C'\fR,
\&\f(CW\*(C`unary \-\*(C'\fR) are extended to support vectors and matrices.  Sizes of
vectors and matrices must be appropriately matched, according to standard
mathematical rules.  Scalar-to-vector promotion, as described earlier,
allows relaxation of these rules.
.IP "\fBM[n][m]\fR" 4
.IX Item "M[n][m]"
Matrix with \f(CW\*(C`n\*(C'\fR rows and \f(CW\*(C`m\*(C'\fR columns
.IP "\fBV[n]\fR" 4
.IX Item "V[n]"
Vector with \f(CW\*(C`n\*(C'\fR elements
.IP "\fB\-V[n] \-> V[n]\fR" 4
.IX Item "-V[n] -> V[n]"
Unary vector negate
.IP "\fB\-M[n] \-> M[n]\fR" 4
.IX Item "-M[n] -> M[n]"
Unary matrix negate
.IP "\fBV[n] * V[n] \-> V[n]\fR" 4
.IX Item "V[n] * V[n] -> V[n]"
Componentwise *
.IP "\fBV[n] / V[n] \-> V[n]\fR" 4
.IX Item "V[n] / V[n] -> V[n]"
Componentwise /
.IP "\fBV[n] % V[n] \-> V[n]\fR" 4
.IX Item "V[n] % V[n] -> V[n]"
Componentwise %
.IP "\fBV[n] + V[n] \-> V[n]\fR" 4
.IX Item "V[n] + V[n] -> V[n]"
Componentwise +
.IP "\fBV[n] \- V[n] \-> V[n]\fR" 4
.IX Item "V[n] - V[n] -> V[n]"
Componentwise \-
.IP "\fBM[n][m] * M[n][m] \-> M[n][m]\fR" 4
.IX Item "M[n][m] * M[n][m] -> M[n][m]"
Componentwise *
.IP "\fBM[n][m] / M[n][m] \-> M[n][m]\fR" 4
.IX Item "M[n][m] / M[n][m] -> M[n][m]"
Componentwise /
.IP "\fBM[n][m] % M[n][m] \-> M[n][m]\fR" 4
.IX Item "M[n][m] % M[n][m] -> M[n][m]"
Componentwise %
.IP "\fBM[n][m] + M[n][m] \-> M[n][m]\fR" 4
.IX Item "M[n][m] + M[n][m] -> M[n][m]"
Componentwise +
.IP "\fBM[n][m] \- M[n][m] \-> M[n][m]\fR" 4
.IX Item "M[n][m] - M[n][m] -> M[n][m]"
Componentwise \-
.Sh "Operators"
.IX Subsection "Operators"
\fIBoolean\fR
.IX Subsection "Boolean"
.PP
.Vb 1
\&       &&  ||  !
.Ve
.PP
Boolean operators may be applied to \f(CW\*(C`bool\*(C'\fR packed bool vectors,
in which case they are applied in elementwise fashion to
produce a result vector of the same size.  Each operand must be a
\&\f(CW\*(C`bool\*(C'\fR vector of the same size.
.PP
Both sides of && and || are always evaluated; there is no
short-circuiting as there is in C.
.PP
\fIComparisons\fR
.IX Subsection "Comparisons"
.PP
.Vb 1
\&        <  >  <=  >=  !=  ==
.Ve
.PP
Comparison operators may be applied to numeric vectors.  Both operands
must be vectors of the same size.  The comparison operation is
performed in elementwise fashion to produce a \f(CW\*(C`bool\*(C'\fR vector of the
same size.
.PP
Comparison operators may also be applied to \f(CW\*(C`bool\*(C'\fR vectors.  For the
purpose of relational comparisons, \f(CW\*(C`true\*(C'\fR is treated as one and
\&\f(CW\*(C`false\*(C'\fR is treated as zero.  The comparison operation is performed in
elementwise fashion to produce a \f(CW\*(C`bool\*(C'\fR vector of the same size.
.PP
Comparison operators may also be applied to numeric or bool scalars.
.PP
\fIArithmetic\fR
.IX Subsection "Arithmetic"
.PP
.Vb 1
\&        +  \-  *  /  %  ++  \-\-  unary\-  unary+
.Ve
.PP
The arithmetic operator \f(CW\*(C`%\*(C'\fR is the remainder operator, as in C. It may
only be applied to two operands of \f(CW\*(C`cint\*(C'\fR or \f(CW\*(C`int\*(C'\fR types.
.PP
When \f(CW\*(C`/\*(C'\fR or \f(CW\*(C`%\*(C'\fR is used with \f(CW\*(C`cint\*(C'\fR or \f(CW\*(C`int\*(C'\fR operands, C rules for
integer \f(CW\*(C`/\*(C'\fR and \f(CW\*(C`%\*(C'\fR apply.
.PP
The C operators that combine assignment with arithmetic operations
(such as \f(CW\*(C`+=\*(C'\fR) are also supported when the corresponding arithmetic
operator is supported by Cg.
.PP
\fIConditional Operator\fR
.IX Subsection "Conditional Operator"
.PP
.Vb 1
\&        ?:
.Ve
.PP
If the first operand is of type \f(CW\*(C`bool\*(C'\fR, one of the following must hold
for the second and third operands:
.IP "\(bu" 4
Both operands have compatible structure types.
.IP "\(bu" 4
Both operands are scalars with numeric or \f(CW\*(C`bool\*(C'\fR type.
.IP "\(bu" 4
Both operands are vectors with numeric or \f(CW\*(C`bool\*(C'\fR type, where the two
vectors are of the same size, which is less than or equal to four.
.PP
If the first operand is a packed vector of \f(CW\*(C`bool\*(C'\fR, then the
conditional selection is performed on an elementwise basis. Both the
second and third operands must be numeric vectors of the same size as
the first operand.
.PP
Unlike C, side effects in the expressions in the second and third
operands are always executed, regardless of the condition.
.PP
\fIMiscellaneous Operators\fR
.IX Subsection "Miscellaneous Operators"
.PP
.Vb 1
\&        (typecast)   ,
.Ve
.PP
Cg supports C's typecast and comma operators.
.SH "Reserved Words"
.IX Header "Reserved Words"
The following are currently used reserved words in Cg.
A '*' indicates that the reserved word is case-insensitive.
.IP "_\|_[anything] (i.e. any identifier with two underscores as a prefix)" 4
.IX Item "__[anything] (i.e. any identifier with two underscores as a prefix)"
.PD 0
.IP "asm*" 4
.IX Item "asm*"
.IP "asm_fragment" 4
.IX Item "asm_fragment"
.IP "auto" 4
.IX Item "auto"
.IP "bool" 4
.IX Item "bool"
.IP "break" 4
.IX Item "break"
.IP "case" 4
.IX Item "case"
.IP "catch" 4
.IX Item "catch"
.IP "char" 4
.IX Item "char"
.IP "class" 4
.IX Item "class"
.IP "column_major" 4
.IX Item "column_major"
.IP "compile" 4
.IX Item "compile"
.IP "const" 4
.IX Item "const"
.IP "const_cast" 4
.IX Item "const_cast"
.IP "continue" 4
.IX Item "continue"
.IP "decl*" 4
.IX Item "decl*"
.IP "default" 4
.IX Item "default"
.IP "delete" 4
.IX Item "delete"
.IP "discard" 4
.IX Item "discard"
.IP "do" 4
.IX Item "do"
.IP "double" 4
.IX Item "double"
.IP "dword*" 4
.IX Item "dword*"
.IP "dynamic_cast" 4
.IX Item "dynamic_cast"
.IP "else" 4
.IX Item "else"
.IP "emit" 4
.IX Item "emit"
.IP "enum" 4
.IX Item "enum"
.IP "explicit" 4
.IX Item "explicit"
.IP "extern" 4
.IX Item "extern"
.IP "false" 4
.IX Item "false"
.IP "fixed" 4
.IX Item "fixed"
.IP "float*" 4
.IX Item "float*"
.IP "for" 4
.IX Item "for"
.IP "friend" 4
.IX Item "friend"
.IP "get" 4
.IX Item "get"
.IP "goto" 4
.IX Item "goto"
.IP "half" 4
.IX Item "half"
.IP "if" 4
.IX Item "if"
.IP "in" 4
.IX Item "in"
.IP "inline" 4
.IX Item "inline"
.IP "inout" 4
.IX Item "inout"
.IP "int" 4
.IX Item "int"
.IP "interface" 4
.IX Item "interface"
.IP "long" 4
.IX Item "long"
.IP "matrix*" 4
.IX Item "matrix*"
.IP "mutable" 4
.IX Item "mutable"
.IP "namespace" 4
.IX Item "namespace"
.IP "new" 4
.IX Item "new"
.IP "operator" 4
.IX Item "operator"
.IP "out" 4
.IX Item "out"
.IP "packed" 4
.IX Item "packed"
.IP "pass*" 4
.IX Item "pass*"
.IP "pixelfragment*" 4
.IX Item "pixelfragment*"
.IP "pixelshader*" 4
.IX Item "pixelshader*"
.IP "private" 4
.IX Item "private"
.IP "protected" 4
.IX Item "protected"
.IP "public" 4
.IX Item "public"
.IP "register" 4
.IX Item "register"
.IP "reinterpret_cast" 4
.IX Item "reinterpret_cast"
.IP "return" 4
.IX Item "return"
.IP "row_major" 4
.IX Item "row_major"
.IP "sampler" 4
.IX Item "sampler"
.IP "sampler_state" 4
.IX Item "sampler_state"
.IP "sampler1D" 4
.IX Item "sampler1D"
.IP "sampler2D" 4
.IX Item "sampler2D"
.IP "sampler3D" 4
.IX Item "sampler3D"
.IP "samplerCUBE" 4
.IX Item "samplerCUBE"
.IP "shared" 4
.IX Item "shared"
.IP "short" 4
.IX Item "short"
.IP "signed" 4
.IX Item "signed"
.IP "sizeof" 4
.IX Item "sizeof"
.IP "static" 4
.IX Item "static"
.IP "static_cast" 4
.IX Item "static_cast"
.IP "string*" 4
.IX Item "string*"
.IP "struct" 4
.IX Item "struct"
.IP "switch" 4
.IX Item "switch"
.IP "technique*" 4
.IX Item "technique*"
.IP "template" 4
.IX Item "template"
.IP "texture*" 4
.IX Item "texture*"
.IP "texture1D" 4
.IX Item "texture1D"
.IP "texture2D" 4
.IX Item "texture2D"
.IP "texture3D" 4
.IX Item "texture3D"
.IP "textureCUBE" 4
.IX Item "textureCUBE"
.IP "textureRECT" 4
.IX Item "textureRECT"
.IP "this" 4
.IX Item "this"
.IP "throw" 4
.IX Item "throw"
.IP "true" 4
.IX Item "true"
.IP "try" 4
.IX Item "try"
.IP "typedef" 4
.IX Item "typedef"
.IP "typeid" 4
.IX Item "typeid"
.IP "typename" 4
.IX Item "typename"
.IP "uniform" 4
.IX Item "uniform"
.IP "union" 4
.IX Item "union"
.IP "unsigned" 4
.IX Item "unsigned"
.IP "using" 4
.IX Item "using"
.IP "vector*" 4
.IX Item "vector*"
.IP "vertexfragment*" 4
.IX Item "vertexfragment*"
.IP "vertexshader*" 4
.IX Item "vertexshader*"
.IP "virtual" 4
.IX Item "virtual"
.IP "void" 4
.IX Item "void"
.IP "volatile" 4
.IX Item "volatile"
.IP "while" 4
.IX Item "while"
.PD
.SH "Cg Standard Library Functions"
.IX Header "Cg Standard Library Functions"
Cg provides a set of built-in functions and structures to simplify \s-1GPU\s0
programming.  These functions are similar in spirit to the C standard
library functions, providing a convenient set of common functions.
.PP
The Cg Standard Library is documented in \*(L"spec_stdlib.txt\*(R".
.SH "VERTEX PROGRAM PROFILES"
.IX Header "VERTEX PROGRAM PROFILES"
A few features of the Cg language that are specific to
vertex program profiles are required to be implemented in the
same manner for all vertex program profiles.
.Sh "Mandatory Computation of Position Output"
.IX Subsection "Mandatory Computation of Position Output"
Vertex program profiles may (and typically do) require that the
program compute a position output.  This homogeneous clip-space
position is used by the hardware rasterizer  and must be stored in a
program output with an output binding semantic of \f(CW\*(C`POSITION\*(C'\fR
(or \f(CW\*(C`HPOS\*(C'\fR for backward compatibility).
.Sh "Position Invariance"
.IX Subsection "Position Invariance"
In many graphics APIs, the user can choose between two different
approaches to specifying per-vertex computations:
use a built-in configurable \*(L"fixed-function\*(R" pipeline or
specify a user-written vertex program.
If the user wishes to mix these two approaches, it is sometimes
desirable to guarantee that the position computed by the first
approach is bit-identical to the position computed by the second
approach.  This \*(L"position invariance\*(R" is particularly important for
multipass rendering.
.PP
Support for position invariance is optional in Cg vertex profiles, but
for those vertex profiles that support it, the following rules apply:
.IP "\(bu" 4
Position invariance with respect to the fixed function pipeline
is guaranteed if two conditions are met:
.RS 4
.IP "\-" 4
A \f(CW\*(C`#pragma position_invariant <top\-level\-function\-name>\*(C'\fR appears
before the body of the top-level function for the vertex program.
.IP "\-" 4
The vertex program computes position as follows:
.Sp
.Vb 1
\&    OUT_POSITION = mul(MVP, IN_POSITION)
.Ve
.Sp
where:
.RS 4
.IP "\s-1OUT_POSITION\s0" 4
.IX Item "OUT_POSITION"
is a variable (or structure element) of type \f(CW\*(C`float4\*(C'\fR with
an output binding semantic of \f(CW\*(C`POSITION\*(C'\fR or \f(CW\*(C`HPOS\*(C'\fR.
.IP "\s-1IN_POSITION\s0" 4
.IX Item "IN_POSITION"
is a variable (or structure element) of type \f(CW\*(C`float4\*(C'\fR with
an input binding semantic of \f(CW\*(C`POSITION\*(C'\fR.
.IP "\s-1MVP\s0" 4
.IX Item "MVP"
is a uniform variable (or structure element) of type
\&\f(CW\*(C`float4x4\*(C'\fR with an input binding semantic that causes it
to track the fixed-function modelview-projection matrix.
(The name of this binding semantic is currently
profile-specific \*(-- for OpenGL profiles, the
semantic \f(CW\*(C`state.matrix.mvp\*(C'\fR is recommended).
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "\(bu" 4
If the first condition is met but not the second, the compiler is
encouraged to issue a warning.
.IP "\(bu" 4
Implementations may choose to recognize more general versions of
the second condition (such as the variables being copy propagated from
the original inputs and outputs), but this additional generality is
not required.
.Sh "Binding Semantics for Outputs"
.IX Subsection "Binding Semantics for Outputs"
As shown in Table 10, there are two output binding semantics for vertex program profiles:
.PP
.Vb 6
\&  Table 10  Vertex Output Binding Semantics
\&  Name      Meaning                       Type     Default Value
\&  \-\-\-\-\-\-\-\-  \-\-\-\-\-\-\-                       \-\-\-\-\-\-   \-\-\-\-\-\-\-\-\-\-\-\-\-
\&  POSITION  Homogeneous clip\-space        float4   Undefined
\&            position; fed to rasterizer.
\&  PSIZE     Point size                    float    Undefined
.Ve
.PP
Profiles may define additional output binding semantics with specific
behaviors, and these definitions are expected to be
consistent across commonly used profiles.
.SH "FRAGMENT PROGRAM PROFILES"
.IX Header "FRAGMENT PROGRAM PROFILES"
A few features of the Cg language that are specific to
fragment program profiles are required to be implemented in the
same manner for all fragment program profiles.
.Sh "Binding semantics for outputs"
.IX Subsection "Binding semantics for outputs"
As shown in Table 11, there are three output binding semantics for fragment program profiles:
.PP
.Vb 7
\& Table 11  Fragment Output Binding Semantics
\& Name    Meaning               Type    Default Value
\& \-\-\-\-    \-\-\-\-\-\-\-               \-\-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-
\& COLOR   RGBA output color     float4  Undefined
\& COLOR0  Same as COLOR
\& DEPTH   Fragment depth value  float   Interpolated depth from rasterizer
\&         (in range [0,1])              (in range [0,1])
.Ve
.PP
Profiles may define additional output binding semantics with specific
behaviors, and these definitions are expected to be
consistent across commonly used profiles.
.PP
If a program desires an output color alpha of 1.0, it should
explicitly write a value of 1.0 to the \f(CW\*(C`W\*(C'\fR component of the \f(CW\*(C`COLOR\*(C'\fR
output.  The language does *not* define a default value for this
output.
.PP
Note: If the target hardware uses a default
value for this output, the compiler may choose to optimize away an
explicit write specified by the user if it matches the default
hardware value.  Such defaults are not exposed in the language.)
.PP
In contrast, the language does define a default value for the \f(CW\*(C`DEPTH\*(C'\fR
output.  This default value is the interpolated depth obtained from
the rasterizer.  Semantically, this default value is copied to the
output at the beginning of the execution of the fragment program.
.PP
As discussed earlier, when a binding semantic is applied to an output,
the type of the output variable is not required to match the type of
the binding semantic.  For example, the following is legal, although
not recommended:
.PP
.Vb 3
\&        struct myfragoutput {
\&            float2 mycolor : COLOR;
\&        }
.Ve
.PP
In such cases, the variable is implicitly copied (with a typecast) to
the semantic upon program completion.  If the variable's vector size
is shorter than the semantic's vector size, the
larger-numbered components of the semantic receive their default
values if applicable, and otherwise are undefined.  In
the case above, the \f(CW\*(C`R\*(C'\fR and \f(CW\*(C`G\*(C'\fR components of the output color are
obtained from \f(CW\*(C`mycolor\*(C'\fR, while the \f(CW\*(C`B\*(C'\fR and \f(CW\*(C`A\*(C'\fR components of the color
are undefined.
